*****   代理模式 需要继承 InvocationHandler 接口 实现 invoke方法    ******
简介：Proxy Pattern/ Surrogate Pattern
    为其他对象提供一种代理一控制对这个对象的访问。
    说白了就是，在一些情况下客户不想或者不能直接引用一个对象，而代理对象可以在客户和目标对象之间起到中介作用，
    去掉客户不能看到的的内容和服务或者添增客户需要的额外服务。
    1、远程 (Remote) 代理
        为一个位于不同的地址空间的对象提供一个局域代表对象。
        比如：你可以将一个在世界某个角落一台机器通过代理假象成你局域网中的一部分
    2、虚拟 (Virtual) 代理
        根据需要将一个资源消耗很大或者比较复杂的对象延迟的真正需要时才创建。
        比如：
            如果一个很大的图片，需要很长的时间才能显示出来，那么当这个图片包含在文档中时，使用编辑器或浏览器
            打开这个文档，这个大图片可能就影响了文档的阅读，这事需要做个Proxy来代替真正的图片
    3、保护 () 代理
        控制对一个对象的访问权限。
        比如：
            在论坛中，不同的身分登录，拥有权限是不同的，使用代理模式可以控制权限。
    4、智能引用 (Smart Refernce) 代理
        提供比对目标对象额外的服务
        比如：
            记录访问的流量，提供一些友情提示等等
结构：
    代理模式就有三个角色组成。
    1) 抽象主题角色 ： 声明了真实主题和代理主题的共同接口
    2) 代理主题角色 ： 内部包含对真实主题的引用，并且提供和真实主题角色相同的接口
    3) 真实主题角色 ： 定义真实的对象
举例：

总结：
    代理模式能够协调调用者和被调用者，能够在一定程度上降低系统的耦合度。
    代理模式的真实主题角色可以结合组合模式来构造，这样一个代理主题角色
    就可以对一系列的真实主题角色有效，提高代码利用率，减少不必要的子类产生。
